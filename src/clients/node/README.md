This file is generated by
[src/clients/docs_generate.zig](/src/clients/docs_generate.zig).

# tigerbeetle-node

The TigerBeetle client for Node.js.

### Prerequisites

* NodeJS >= `14`. _(If the correct version is not installed, an installation error will occur)_

> Your operating system should be Linux (kernel >= v5.6) or macOS.
> Windows support is not yet available.

## Setup

```console
$ npm install tigerbeetle-node
```

Create `test.js` and copy this into it:

```javascript
const { createClient } = require("tigerbeetle-node");
console.log("Import ok!");
```

And run:

```console
$ node run test.js
```

If you run into issues, check out the distribution-specific install
steps that are run in CI to test support:

* [Alpine](./scripts/test_install_on_alpine.sh)
* [Amazon Linux](./scripts/test_install_on_amazonlinux.sh)
* [Debian](./scripts/test_install_on_debian.sh)
* [Fedora](./scripts/test_install_on_fedora.sh)
* [Ubuntu](./scripts/test_install_on_ubuntu.sh)
* [RHEL](./scripts/test_install_on_rhelubi.sh)

### Sidenote: `BigInt`
TigerBeetle uses 64-bit integers for many fields while JavaScript's
builtin `Number` maximum value is `2^53-1`. The `n` suffix in JavaScript
means the value is a `BigInt`. This is useful for literal numbers. If
you already have a `Number` variable though, you can call the `BigInt`
constructor to get a `BigInt` from it. For example, `1n` is the same as
`BigInt(1)`.

## Creating a Client

```javascript
const client = createClient({
  cluster_id: 0,
  replica_addresses: ['3001', '3002', '3003']
});
```

The following are valid addresses:
* `3000` (interpreted as `127.0.0.1:3000`)
* `127.0.0.1:3000` (interpreted as `127.0.0.1:3000`)
* `127.0.0.1` (interpreted as `127.0.0.1:3001`, `3001` is the default port)

## Creating Accounts

See details for account fields in the [Accounts
reference](https://docs.tigerbeetle.com/reference/accounts).

```javascript
const account = {
  id: 137n, // u128
  user_data: 0n, // u128, opaque third-party identifier to link this account to an external entity:
  reserved: Buffer.alloc(48, 0), // [48]u8
  ledger: 1,   // u32, ledger value
  code: 718, // u16, a chart of accounts code describing the type of account (e.g. clearing, settlement)
  flags: 0,  // u16
  debits_pending: 0n,  // u64
  debits_posted: 0n,  // u64
  credits_pending: 0n, // u64
  credits_posted: 0n, // u64
  timestamp: 0n, // u64, Reserved: This will be set by the server.
};

const accountErrors = await client.createAccounts([account]);
if (accountErrors.length) {
  // Grab a human-readable message from the response
  console.log(CreateAccountError[accountErrors[0].code]);
}
```

### Account Flags

The account flags value is a bitfield. See details for
these flags in the [Accounts
reference](https://docs.tigerbeetle.com/reference/accounts#flags).

To toggle behavior for an account, combine enum values stored in the
`AccountFlags` object (in TypeScript it is an actual enum) with
bitwise-or:

* `AccountFlags.linked`
* `AccountFlags.debits_must_not_exceed_credits`
* `AccountFlags.credits_must_not_exceed_credits`

For example, to link `account0` and `account1`, where `account0`
additionally has the `debits_must_not_exceed_credits` constraint:

```js
const account0 = { ... account values ... };
const account1 = { ... account values ... };
account0.flags = AccountFlags.linked | AccountFlags.debits_must_not_exceed_credits;
// Create the account
const accountErrors = client.createAccounts([account0, account1]);
```

### Response and Errors

The response is an empty array if all accounts were
created successfully. If the response is non-empty, each
object in the response array contains error information
for an account that failed. The error object contains an
error code and the index of the account in the request
batch.

See all error conditions in the [create_accounts
reference](https://docs.tigerbeetle.com/reference/operations/create_accounts).

```javascript
const accountErrors = await client.createAccounts([account1, account2, account3]);

// accountErrors = [{ index: 1, code: 1 }];
for (const error of accountErrors) {
  switch (error.code) {
    case CreateAccountError.exists:
      console.error(`Batch account at ${error.index} already exists.`);
	  break;
    default:
      console.error(`Batch account at ${error.index} failed to create: ${CreateAccountError[error.code]}.`);
  }
}
```

To handle errors you can either 1) exactly match error codes returned
from `client.createAccounts` with enum values in the
`CreateAccountError` object, or you can 2) look up the error code in
the `CreateAccountError` object for a human-readable string.

## Account Lookup

Account lookup is batched, like account creation. Pass
in all IDs to fetch, and matched accounts are returned.

If no account matches an ID, no object is returned for
that account. So the order of accounts in the response is
not necessarily the same as the order of IDs in the
request. You can refer to the ID field in the response to
distinguish accounts.

```javascript
// account 137n exists, 138n does not
const accounts = await client.lookupAccounts([137n, 138n]);
console.log(accounts);
```

## Create Transfers

This creates a journal entry between two accounts.

See details for transfer fields in the [Transfers
reference](https://docs.tigerbeetle.com/reference/transfers).

### Response and Errors

The response is an empty array if all transfers were created
successfully. If the response is non-empty, each object in the
response array contains error information for an transfer that
failed. The error object contains an error code and the index of the
transfer in the request batch.

See all error conditions in the [create_transfers
reference](https://docs.tigerbeetle.com/reference/operations/create_transfers).

```javascript
const transferErrors = await client.createTransfers([transfer1, transfer2, transfer3]);

// transferErrors = [{ index: 1, code: 1 }];
for (const error of transferErrors) {
  switch (error.code) {
    case CreateTransferError.exists:
      console.error(`Batch transfer at ${error.index} already exists.`);
	  break;
    default:
      console.error(`Batch transfer at ${error.index} failed to create: ${CreateTransferError[error.code]}.`);
  }
}
```

The example above shows that the transfer in index 1 failed with
error 1. This error here means that `transfer1` and `transfer3` were
created successfully. But `transfer2` was not created.

To handle errors you can either 1) exactly match error codes returned
from `client.createTransfers` with enum values in the
`CreateTransferError` object, or you can 2) look up the error code in
the `CreateTransferError` object for a human-readable string.

### Batching

TigerBeetle performance is maximized when you batch
inserts. The client does not do this automatically for
you. So, for example, you *can* insert 1 million transfers
one at a time like so:

```javascript
for (let i = 0; i < transfers.len; i++) {
  const transferErrors = client.createTransfers(transfers[i]);
  // error handling omitted
}
```

But the insert rate will be a *fraction* of
potential. Instead, **always batch what you can**.

The maximum batch size is set in the TigerBeetle server. The default
is 8191.

```javascript
const BATCH_SIZE = 8191;
for (let i = 0; i < transfers.length; i += BATCH_SIZE) {
  const transferErrors = client.createTransfers(transfers.slice(i, Math.min(transfers.length, BATCH_SIZE)));
  // error handling omitted
}
```

## Complete sample file

```javascript
const { createClient } = require("tigerbeetle-node");

async function main() {
  const client = createClient({
    cluster_id: 0,
    replica_addresses: ["3001", "3002", "3003"],
  });
  const account = {
    id: 137n, // u128
    user_data: 0n, // u128, opaque third-party identifier to link this account to an external entity:
    reserved: Buffer.alloc(48, 0), // [48]u8
    ledger: 1, // u32, ledger value
    code: 718, // u16, a chart of accounts code describing the type of account (e.g. clearing, settlement)
    flags: 0, // u16
    debits_pending: 0n, // u64
    debits_posted: 0n, // u64
    credits_pending: 0n, // u64
    credits_posted: 0n, // u64
    timestamp: 0n, // u64, Reserved: This will be set by the server.
  };

  const accountErrors = await client.createAccounts([account]);
  if (accountErrors.length) {
    // Grab a human-readable message from the response
    console.log(CreateAccountError[accountErrors[0].code]);
  }
  // account 137n exists, 138n does not
  const accounts = await client.lookupAccounts([137n, 138n]);
  console.log(accounts);
  const transfer = {
    id: 1n, // u128
    pending_id: 0n, // u128
    // Double-entry accounting:
    debit_account_id: 1n, // u128
    credit_account_id: 2n, // u128
    // Opaque third-party identifier to link this transfer to an external entity:
    user_data: 0n, // u128
    reserved: 0n, // u128
    // Timeout applicable for a pending/2-phase transfer:
    timeout: 0n, // u64, in nano-seconds.
    // Collection of accounts usually grouped by the currency:
    // You can't transfer money between accounts with different ledgers:
    ledger: 1, // u32, ledger for transfer (e.g. currency).
    // Chart of accounts code describing the reason for the transfer:
    code: 720, // u16, (e.g. deposit, settlement)
    flags: 0, // u16
    amount: 10n, // u64
    timestamp: 0n, //u64, Reserved: This will be set by the server.
  };
  const transferErrors = await client.createTransfers([transfer]);
  for (const error of transferErrors) {
    switch (error.code) {
      default:
        console.error(
          `Batch transfer at ${error.index} failed to create: ${
            CreateAccountError[error.code]
          }.`
        );
    }
  }
}
main()
  .then(() => process.exit(0))
  .catch((e) => {
    console.error(e);
    process.exit(1);
  });

```

## Development Setup

### On Linux and macOS

```console
$ npm install --include dev # This will automatically install and build everything you need.
```

### On Windows

```console
$ npm install --include dev # This will automatically install and build everything you need.
```

